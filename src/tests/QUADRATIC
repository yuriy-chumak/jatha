;;; lisp

(defun second (l) (car (cdr l)))

;; --- Functions needed to implement macros -----

(defun combine-exprs (lft rgt expr)
  (if (and (constantp lft) (constantp rgt)) (list 'quote expr)
     (if (null rgt) (list 'list lft)
       (if (and (consp rgt) (eql (car rgt) 'list))  (cons 'list (cons lft (cdr rgt )))
         (list 'cons lft rgt ))))) 


(defun f-backquote (expr)
  (if (null expr) nil 
    (if (atom expr) (list 'quote expr)
       (if (eq (car expr) :COMMA) (second expr)  
         (if (and (consp (car expr)) (eq (car (car expr)) :COMMA-ATSIGN )) 
            (list 'append (second (car expr)) (f-backquote (cdr expr))) 
         (combine-exprs (f-backquote (car expr)) 
            (f-backquote (cdr expr)) expr) )))))

(defmacro backquote (expr)
   (f-backquote expr))

;; ------------------------------------------------
;; COND
;; ------------------------------------------------
(defun f-cond (l)
  (if (null l) nil
    (let ((clause (car l))) 
      `(if ,(car clause) (progn ,@(cdr clause))
        ,(f-cond (cdr l))))))

(defmacro cond (&rest l) 
   (f-cond l))



;; ------------------------------------------------
;; TEST
;; ------------------------------------------------
;; 
(progn
(defun quadratic-roots-2 (A B C)
  (cond ((= A 0) (string "Not a quadratic equation."))
    (t
    (let ((D (- (* B B) (* 4 A C))))
      (cond ((= D 0) (concatenate 'string "x = " (/ (+ (- B) (sqrt D)) (* 2 A))))
        (t
        (cons (concatenate 'string "x1 = " (/ (+ (- B) (sqrt D)) (* 2 A)))
              (concatenate 'string "x2 = " (/ (- (- B) (sqrt D)) (* 2 A))))))))))
t)

(let ((xx (quadratic-roots-2 2 4 -6))) 
  (and (string-equal (car xx) "x1 = 1")
       (string-equal (cdr xx) "x2 = -3")))
